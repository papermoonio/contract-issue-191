"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const config_1 = require("hardhat/config");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const plugins_1 = require("hardhat/plugins");
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const servers_1 = require("./servers");
const utils_1 = require("./utils");
const errors_1 = require("./errors");
const global_interceptor_1 = require("./core/global-interceptor");
const script_runner_1 = require("./core/script-runner");
require("./type-extensions");
(0, config_1.task)(task_names_1.TASK_RUN).setAction(async (args, hre, runSuper) => {
    if (!hre.network.polkavm || hre.network.name !== plugins_1.HARDHAT_NETWORK_NAME) {
        await runSuper(args, hre);
        return;
    }
    await (0, script_runner_1.runScriptWithHardhat)({
        forking: hre.config.networks.hardhat.forking,
        forkBlockNumber: hre.config.networks.hardhat.forking?.blockNumber,
        nodeCommands: hre.userConfig.networks?.hardhat?.nodeConfig,
        adapterCommands: hre.userConfig.networks?.hardhat?.adapterConfig,
    }, hre.hardhatArguments, path_1.default.resolve(args.script));
});
(0, config_1.subtask)(constants_1.TASK_NODE_POLKADOT_CREATE_SERVER, "Creates a JSON-RPC server for Polkadot node")
    .addOptionalParam("nodePath", "Path to the node binary file", undefined, config_1.types.string)
    .addOptionalParam("adapterPath", "Path to the Eth Rpc Adapter binary file", undefined, config_1.types.string)
    .setAction(async ({ nodePath, adapterPath }, { config }) => {
    const server = (0, servers_1.createRpcServer)({
        nodePath,
        adapterPath,
        isForking: config.networks.hardhat.forking?.enabled,
    });
    return server;
});
(0, config_1.task)(task_names_1.TASK_NODE, "Start a Polkadot Node").setAction(async (args, { network, run }, runSuper) => {
    if (network.polkavm !== true || network.name !== plugins_1.HARDHAT_NETWORK_NAME) {
        return await runSuper();
    }
    await run(constants_1.TASK_NODE_POLKADOT, args);
});
(0, config_1.task)(constants_1.TASK_NODE_POLKADOT, "Starts a JSON-RPC server for Polkadot node")
    .addOptionalParam("nodeBinaryPath", "Path to the substrate node binary", undefined, config_1.types.string)
    .addOptionalParam("rpcPort", "Port where the node will listen on - default: 8000", undefined, config_1.types.int)
    .addOptionalParam("adapterBinaryPath", "Path to the eth-rpc-adapter binary", undefined, config_1.types.string)
    /**
     * @deprecated This property should not be used
     */
    .addOptionalParam("adapterEndpoint", "Endpoint to which the adapter will connect to - default: ws://localhost:8000", undefined, config_1.types.string)
    .addOptionalParam("adapterPort", "Port where the adapter will listen on - default: 8545 ", undefined, config_1.types.int)
    .addOptionalParam("dev", "Whether to run the adapter in dev mode - default: false", undefined, config_1.types.boolean)
    .addOptionalParam("buildBlockMode", "Build block mode for @acala-network/chopsticks", undefined, config_1.types.string)
    .addOptionalParam("fork", "Endpoint to fork a live chain using @acala-network/chopsticks", undefined, config_1.types.string)
    .addOptionalParam("forkBlockNumber", "Block hash or block number from where to fork", undefined, config_1.types.string)
    .setAction(async ({ nodeBinaryPath, rpcPort, adapterBinaryPath, adapterEndpoint, adapterPort, dev, buildBlockMode, fork, forkBlockNumber, }, { run, config, userConfig }) => {
    const commandArgs = (0, utils_1.constructCommandArgs)({
        forking: config.networks.hardhat.forking,
        forkBlockNumber: config.networks.hardhat.forking?.blockNumber,
        nodeCommands: userConfig.networks?.hardhat?.nodeConfig,
        adapterCommands: userConfig.networks?.hardhat?.adapterConfig,
    }, {
        nodeBinaryPath,
        rpcPort,
        adapterBinaryPath,
        adapterEndpoint,
        adapterPort,
        dev,
        buildBlockMode,
        fork,
        forkBlockNumber,
    });
    const nodePath = nodeBinaryPath
        ? nodeBinaryPath
        : userConfig.networks?.hardhat?.nodeConfig?.nodeBinaryPath;
    const adapterPath = adapterBinaryPath
        ? adapterBinaryPath
        : userConfig.networks?.hardhat?.adapterConfig?.adapterBinaryPath;
    const server = await run(constants_1.TASK_NODE_POLKADOT_CREATE_SERVER, {
        nodePath,
        adapterPath,
    });
    try {
        await server.listen(commandArgs.nodeCommands, commandArgs.adapterCommands);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    catch (error) {
        throw new errors_1.PolkadotNodePluginError(`Failed when running node: ${error.message}`);
    }
});
(0, config_1.subtask)(constants_1.TASK_RUN_POLKADOT_NODE_IN_SEPARATE_PROCESS, "Runs a Hardhat Polkadot task in a separate process.")
    .addVariadicPositionalParam("taskArgs", "Arguments for the Hardhat Polkadot task.")
    .setAction(async ({ taskArgs = [] }, _hre) => {
    const currentPort = await (0, utils_1.getAvailablePort)(constants_1.ETH_RPC_ADAPTER_START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const adjustedArgs = (0, utils_1.adjustTaskArgsForPort)(taskArgs, currentPort);
    const taskProcess = (0, child_process_1.spawn)("npx", ["hardhat", constants_1.TASK_NODE_POLKADOT, ...adjustedArgs], {
        detached: true,
    });
    return {
        process: taskProcess,
        port: currentPort,
    };
});
(0, config_1.task)(task_names_1.TASK_TEST, async ({ testFiles, noCompile, parallel, bail, grep, }, { run, network, userConfig, config }, runSuper) => {
    if (network.polkavm !== true || network.name !== plugins_1.HARDHAT_NETWORK_NAME) {
        return await runSuper();
    }
    if (!noCompile) {
        await run(task_names_1.TASK_COMPILE, { quiet: true });
    }
    const files = await run(task_names_1.TASK_TEST_GET_TEST_FILES, { testFiles });
    let nodePort = userConfig.networks?.hardhat?.nodeConfig?.rpcPort || constants_1.NODE_START_PORT;
    let adapterPort = userConfig.networks?.hardhat?.adapterConfig?.adapterPort || constants_1.ETH_RPC_ADAPTER_START_PORT;
    nodePort = await (0, utils_1.getAvailablePort)(nodePort, constants_1.MAX_PORT_ATTEMPTS);
    adapterPort = await (0, utils_1.getAvailablePort)(adapterPort, constants_1.MAX_PORT_ATTEMPTS);
    const nodeCommands = Object.assign({}, userConfig.networks?.hardhat?.nodeConfig, {
        rpcPort: nodePort,
    });
    const adapterCommands = Object.assign({}, userConfig.networks?.hardhat?.adapterConfig, {
        adapterPort,
    });
    const commandArgs = (0, utils_1.constructCommandArgs)({
        forking: config.networks.hardhat.forking,
        forkBlockNumber: config.networks.hardhat.forking?.blockNumber,
        nodeCommands,
        adapterCommands,
    });
    const server = (0, servers_1.createRpcServer)({
        nodePath: userConfig.networks?.hardhat?.nodeConfig?.nodeBinaryPath,
        adapterPath: userConfig.networks?.hardhat?.adapterConfig?.adapterBinaryPath,
        isForking: config.networks.hardhat.forking?.enabled || false,
    });
    try {
        await server.listen(commandArgs.nodeCommands, commandArgs.adapterCommands, false);
        await (0, utils_1.waitForNodeToBeReady)(nodePort);
        await (0, utils_1.waitForNodeToBeReady)(adapterPort, true);
        await (0, utils_1.configureNetwork)(config, network, adapterPort || nodePort);
        let testFailures = 0;
        try {
            testFailures = await run(task_names_1.TASK_TEST_RUN_MOCHA_TESTS, {
                testFiles: files,
                parallel,
                bail,
                grep,
            });
        }
        finally {
            await server.stop();
        }
        process.exitCode = testFailures;
        return testFailures;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    catch (error) {
        throw new errors_1.PolkadotNodePluginError(`Failed when running node: ${error.message}`);
    }
});
(0, global_interceptor_1.interceptAndWrapTasksWithNode)();
//# sourceMappingURL=index.js.map