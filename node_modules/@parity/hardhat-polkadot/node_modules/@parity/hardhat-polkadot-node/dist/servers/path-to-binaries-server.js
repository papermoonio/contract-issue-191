"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathToBinariesRpcServer = void 0;
const child_process_1 = require("child_process");
const chalk_1 = __importDefault(require("chalk"));
const constants_1 = require("../constants");
const errors_1 = require("../errors");
class PathToBinariesRpcServer {
    nodeBinaryPath;
    adapterBinaryPath;
    serverProcess = null;
    adapterProcess = null;
    serverPort = null;
    constructor(nodeBinaryPath, adapterBinaryPath) {
        this.nodeBinaryPath = nodeBinaryPath;
        this.adapterBinaryPath = adapterBinaryPath;
    }
    listen(nodeArgs = [], adapterArgs = [], blockProcess = true) {
        return new Promise((resolve, reject) => {
            const nodeCommand = this.nodeBinaryPath && nodeArgs.find((arg) => arg.startsWith("--forking="))
                ? this.nodeBinaryPath
                : nodeArgs[0];
            const nodeCommandArgs = nodeArgs.slice(1);
            const nodePortArg = nodeArgs.find((arg) => arg.startsWith("--rpc-port="));
            const nodePort = nodePortArg ? parseInt(nodePortArg.split("=")[1], 10) : constants_1.NODE_START_PORT;
            if (blockProcess) {
                console.info(chalk_1.default.green(`Starting server at 127.0.0.1:${nodePort}`));
                console.info(chalk_1.default.green(`Running command: ${nodeCommand} ${nodeCommandArgs.join(" ")}`));
            }
            let stdioConfig = "inherit";
            if (!blockProcess) {
                stdioConfig = ["ignore", "ignore", "ignore"];
            }
            this.serverPort = nodePort;
            this.serverProcess = (0, child_process_1.spawn)(nodeCommand, nodeCommandArgs, { stdio: stdioConfig });
            const adapterCommand = this.adapterBinaryPath;
            if (!adapterCommand) {
                throw new errors_1.PolkadotNodePluginError("A path for the Eth RPC Adapter must be provided.");
            }
            const adapterPortArg = adapterArgs.find((arg) => arg.startsWith("--port="));
            const adapterPort = adapterPortArg
                ? parseInt(adapterPortArg.split("=")[1], 10)
                : constants_1.ETH_RPC_ADAPTER_START_PORT;
            this.adapterProcess = (0, child_process_1.spawn)(adapterCommand, adapterArgs, { stdio: stdioConfig });
            if (blockProcess) {
                console.info(chalk_1.default.green(`Starting the Eth RPC Adapter at 127.0.0.1:${adapterPort}`));
                console.info(chalk_1.default.green(`Running command: ${adapterCommand} ${adapterArgs.join(" ")}`));
            }
            let terminatedProcesses = 0;
            const processExitHandler = (process, name, _port) => {
                process.on("exit", (code, signal) => {
                    if (signal) {
                        console.info(chalk_1.default.yellow(`Received ${signal} signal. The ${name} process has exited.`));
                    }
                    else if (code !== 0) {
                        console.info(chalk_1.default.red(`The ${name} process exited with code: ${code}`));
                    }
                    terminatedProcesses++;
                    if (terminatedProcesses === 2) {
                        if (this.serverProcess?.exitCode === null &&
                            this.adapterProcess?.exitCode === 0) {
                            console.info(chalk_1.default.green("Both processes exited successfully."));
                        }
                        else {
                            console.warn(chalk_1.default.yellow("One or both processes did not exit normally."));
                        }
                        resolve();
                    }
                });
            };
            this.serverProcess.on("error", (error) => {
                console.info(chalk_1.default.red("Error running the server:", error));
                reject(new Error(`Error running the server: ${error.message}`));
            });
            this.adapterProcess.on("error", (error) => {
                console.info(chalk_1.default.red("Error running the Eth RPC Adapter:", error));
                reject(new Error(`Error running the Eth RPC Adapter: ${error.message}`));
            });
            processExitHandler(this.adapterProcess, "adapter");
            processExitHandler(this.serverProcess, "server", this.serverPort);
            if (!blockProcess) {
                resolve();
            }
        });
    }
    stop() {
        return new Promise((resolve) => {
            if (this.adapterProcess && !this.adapterProcess.killed) {
                this.adapterProcess.kill();
            }
            if (this.serverProcess && !this.serverProcess.killed) {
                this.serverProcess.kill();
            }
            resolve();
        });
    }
}
exports.PathToBinariesRpcServer = PathToBinariesRpcServer;
//# sourceMappingURL=path-to-binaries-server.js.map