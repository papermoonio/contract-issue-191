"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructCommandArgs = constructCommandArgs;
exports.isPortAvailable = isPortAvailable;
exports.waitForNodeToBeReady = waitForNodeToBeReady;
exports.getAvailablePort = getAvailablePort;
exports.adjustTaskArgsForPort = adjustTaskArgsForPort;
exports.getNetworkConfig = getNetworkConfig;
exports.configureNetwork = configureNetwork;
exports.startServer = startServer;
const axios_1 = __importDefault(require("axios"));
const net_1 = __importDefault(require("net"));
const construction_1 = require("hardhat/internal/core/providers/construction");
const chalk_1 = __importDefault(require("chalk"));
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const servers_1 = require("./servers");
function constructCommandArgs(args, cliCommands) {
    const nodeCommands = [];
    const adapterCommands = [];
    if (cliCommands && Object.values(cliCommands).find((v) => v !== undefined)) {
        if (cliCommands.adapterEndpoint) {
            console.log(chalk_1.default.yellow("The parameter adapterEndpoint is deprecated and will be ignored.\nThe endpoint the adapter connects to is defined by the node rpc port or the forking url."));
        }
        if (cliCommands.fork) {
            nodeCommands.push(`npx`);
            nodeCommands.push(`@acala-network/chopsticks@latest`);
            nodeCommands.push(`--endpoint=${cliCommands.fork}`);
        }
        else if (cliCommands.nodeBinaryPath) {
            nodeCommands.push(cliCommands.nodeBinaryPath);
        }
        if (cliCommands.rpcPort) {
            nodeCommands.push(`--rpc-port=${cliCommands.rpcPort}`);
            adapterCommands.push(`--node-rpc-url=ws://localhost:${cliCommands.rpcPort}`);
        }
        else {
            adapterCommands.push(`--node-rpc-url=ws://localhost:8000`);
        }
        if (cliCommands.adapterPort && cliCommands.adapterPort !== cliCommands.rpcPort) {
            adapterCommands.push(`--rpc-port=${cliCommands.adapterPort}`);
        }
        else if (cliCommands.adapterPort && cliCommands.adapterPort === cliCommands.rpcPort) {
            throw new errors_1.PolkadotNodePluginError("Adapter and node cannot share the same port.");
        }
        if (cliCommands.fork) {
            nodeCommands.push(`--build-block-mode=${cliCommands.buildBlockMode || "Instant"}`);
        }
        if (cliCommands.dev) {
            adapterCommands.push("--dev");
            if (cliCommands.nodeBinaryPath && !cliCommands.fork) {
                nodeCommands.push("--dev");
            }
        }
    }
    if (args && Object.values(args).find((v) => v !== undefined)) {
        if (args.adapterCommands?.adapterEndpoint) {
            console.log(chalk_1.default.yellow("The parameter adapterEndpoint is deprecated and will be ignored.\nThe endpoint the adapter connects to is defined by the node rpc port or the forking url."));
        }
        if (args.forking && !cliCommands?.fork) {
            nodeCommands.push(`npx`);
            nodeCommands.push(`@acala-network/chopsticks@latest`);
            nodeCommands.push(`--endpoint=${args.forking.url}`);
        }
        else if (args.nodeCommands?.nodeBinaryPath && !cliCommands?.nodeBinaryPath) {
            nodeCommands.push(args.nodeCommands?.nodeBinaryPath);
        }
        if (args.nodeCommands?.rpcPort && !cliCommands?.rpcPort) {
            nodeCommands.push(`--rpc-port=${args.nodeCommands.rpcPort}`);
            adapterCommands.push(`--node-rpc-url=ws://localhost:${args.nodeCommands.rpcPort}`);
        }
        else if (!cliCommands?.rpcPort) {
            adapterCommands.push(`--node-rpc-url=ws://localhost:8000`);
        }
        if (args.adapterCommands?.adapterPort &&
            args.adapterCommands?.adapterPort === args.nodeCommands?.rpcPort) {
            throw new errors_1.PolkadotNodePluginError("Adapter and node cannot share the same port.");
        }
        if (args.forking && !cliCommands?.buildBlockMode) {
            nodeCommands.push(`--build-block-mode=${args.adapterCommands?.buildBlockMode || "Instant"}`);
        }
        if (args.nodeCommands?.nodeBinaryPath &&
            args.nodeCommands.dev &&
            !cliCommands?.dev &&
            !args.forking) {
            nodeCommands.push(`--dev`);
        }
        if (args.adapterCommands?.dev && !cliCommands?.dev) {
            adapterCommands.push("--dev");
        }
    }
    return {
        nodeCommands,
        adapterCommands,
    };
}
async function isPortAvailableForIP(port, ip) {
    return new Promise((resolve) => {
        const tester = net_1.default
            .createServer()
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .once("error", (err) => resolve(err.code !== "EADDRINUSE"))
            .once("listening", () => tester.close(() => resolve(true)))
            .listen(port, ip);
    });
}
async function isPortAvailable(port) {
    const availableIPv4 = await isPortAvailableForIP(port, "0.0.0.0");
    const availableIPv6 = await isPortAvailableForIP(port, "::");
    return availableIPv4 && availableIPv6;
}
function setPayload(adapter) {
    return {
        jsonrpc: "2.0",
        method: adapter ? constants_1.RPC_ENDPOINT_PATH : "state_getRuntimeVersion",
        params: [],
        id: 1,
    };
}
async function waitForNodeToBeReady(port, adapter = false, maxAttempts = 20) {
    const rpcEndpoint = `${constants_1.BASE_URL}:${port}`;
    const payload = setPayload(adapter);
    let attempts = 0;
    let waitTime = 1000;
    const backoffFactor = 2;
    const maxWaitTime = 30000;
    while (attempts < maxAttempts) {
        try {
            const response = await axios_1.default.post(rpcEndpoint, payload);
            if (response.status == 200) {
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (_e) {
            // If it fails, it will just try again
        }
        attempts++;
        await new Promise((r) => setTimeout(r, waitTime));
        waitTime = Math.min(waitTime * backoffFactor, maxWaitTime);
    }
    throw new errors_1.PolkadotNodePluginError("Server didn't respond after multiple attempts");
}
async function getAvailablePort(startPort, maxAttempts) {
    let currentPort = startPort;
    for (let i = 0; i < maxAttempts; i++) {
        if (await isPortAvailable(currentPort)) {
            return currentPort;
        }
        currentPort++;
    }
    throw new errors_1.PolkadotNodePluginError("Couldn't find an available port after several attempts");
}
function adjustTaskArgsForPort(taskArgs, currentPort) {
    const portArg = "--port";
    const portArgIndex = taskArgs.indexOf(portArg);
    if (portArgIndex !== -1) {
        if (portArgIndex + 1 < taskArgs.length) {
            taskArgs[portArgIndex + 1] = `${currentPort}`;
        }
        else {
            throw new errors_1.PolkadotNodePluginError("Invalid task arguments: --port provided without a following port number.");
        }
    }
    else {
        taskArgs.push(portArg, `${currentPort}`);
    }
    return taskArgs;
}
function getNetworkConfig(url, chainId) {
    return {
        accounts: constants_1.NETWORK_ACCOUNTS.POLKADOT,
        gas: constants_1.NETWORK_GAS.AUTO,
        gasPrice: constants_1.NETWORK_GAS_PRICE.AUTO,
        gasMultiplier: 1,
        httpHeaders: {},
        timeout: 20000,
        url,
        ethNetwork: constants_1.NETWORK_ETH.LOCALHOST,
        chainId: chainId || 420420421,
    };
}
async function configureNetwork(config, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
network, port) {
    const url = `${constants_1.BASE_URL}:${port}`;
    const payload = setPayload(true);
    let chainId = 0;
    try {
        const response = await axios_1.default.post(url, payload);
        if (response.status == 200) {
            chainId = parseInt(response.data.result);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    catch (_e) {
        console.log("configureNetwork", _e);
        // If it fails, it will just try again
    }
    network.name = constants_1.POLKADOT_TEST_NODE_NETWORK_NAME;
    network.config = getNetworkConfig(url, chainId);
    config.networks[network.name] = network.config;
    network.provider = await (0, construction_1.createProvider)(config, network.name);
}
async function startServer(commands, nodePath, adapterPath) {
    const currentNodePort = await getAvailablePort(commands.nodeCommands?.rpcPort ? commands.nodeCommands.rpcPort : constants_1.NODE_START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const currentAdapterPort = await getAvailablePort(commands.nodeCommands?.rpcPort ? commands.nodeCommands.rpcPort : constants_1.ETH_RPC_ADAPTER_START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const updatedCommands = Object.assign({}, commands, {
        nodeCommands: { port: currentNodePort },
        adapterCommands: { adapterPort: currentAdapterPort },
    });
    const commandArgs = constructCommandArgs(updatedCommands);
    return {
        commandArgs,
        server: (0, servers_1.createRpcServer)({
            nodePath,
            adapterPath: adapterPath || commands.adapterCommands?.adapterBinaryPath,
            isForking: commands.forking?.enabled,
        }),
        port: currentAdapterPort,
    };
}
//# sourceMappingURL=utils.js.map