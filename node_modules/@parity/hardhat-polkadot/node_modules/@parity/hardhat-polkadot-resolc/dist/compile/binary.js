"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileWithBinary = compileWithBinary;
const child_process_1 = require("child_process");
const utils_1 = require("../utils");
async function compileWithBinary(input, config) {
    const { compilerPath, batchSize } = config.settings;
    const commands = (0, utils_1.extractCommands)(config);
    const processCommand = `${compilerPath} ${commands.join(" ")}`;
    const map = (0, utils_1.mapImports)(input);
    const ordered = (0, utils_1.orderSources)(map);
    let parsedOutput = {
        contracts: {},
        sources: {},
        errors: [],
        version: "",
        long_version: "",
        revive_version: "",
    };
    if (batchSize) {
        console.log("`batchSize` is an experimental feature and may fail when used with smart contracts that employ relative imports.");
        let selectedContracts = {};
        for (let i = 0; i < ordered.length; i += batchSize) {
            selectedContracts = ordered.slice(i, i + batchSize).reduce((acc, key) => {
                acc[key] = input.sources[key];
                return acc;
            }, {});
            const contractBatch = {
                language: input.language,
                sources: selectedContracts,
                settings: input.settings,
            };
            const output = await new Promise((resolve, reject) => {
                const process = (0, child_process_1.exec)(processCommand, {
                    maxBuffer: 1024 * 1024 * 500,
                }, (err, stdout, _stderr) => {
                    if (err !== null) {
                        return reject(err);
                    }
                    resolve(stdout);
                });
                process.stdin.write(JSON.stringify(contractBatch));
                process.stdin.end();
            });
            const parsed = JSON.parse(output);
            parsedOutput = (0, utils_1.deepUpdate)(parsedOutput, parsed);
        }
        return parsedOutput;
    }
    else {
        const output = await new Promise((resolve, reject) => {
            const process = (0, child_process_1.exec)(processCommand, {
                maxBuffer: 1024 * 1024 * 500,
            }, (err, stdout, _stderr) => {
                if (err !== null) {
                    return reject(err);
                }
                resolve(stdout);
            });
            process.stdin.write(JSON.stringify(input));
            process.stdin.end();
        });
        return JSON.parse(output);
    }
}
//# sourceMappingURL=binary.js.map