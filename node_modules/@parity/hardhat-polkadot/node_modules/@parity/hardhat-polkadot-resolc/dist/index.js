"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const debug_1 = __importDefault(require("debug"));
const config_env_1 = require("hardhat/internal/core/config/config-env");
const artifacts_1 = require("hardhat/internal/artifacts");
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const utils_1 = require("./utils");
const compile_1 = require("./compile");
const constants_1 = require("./constants");
require("./type-extensions");
const errors_1 = require("./errors");
const logDebug = (0, debug_1.default)("hardhat:core:tasks:compile");
(0, config_env_1.extendConfig)((config, userConfig) => {
    if (!config.networks.hardhat.polkavm)
        return;
    const isBinary = config.resolc?.compilerSource === "binary";
    const deafaulConfig = isBinary ? constants_1.defaultBinaryResolcConfig : constants_1.defaultNpmResolcConfig;
    const customConfig = userConfig?.resolc || {};
    config.resolc = {
        ...deafaulConfig,
        ...customConfig,
        settings: {
            ...deafaulConfig.settings,
            ...customConfig.settings,
        },
    };
});
(0, config_env_1.extendEnvironment)((hre) => {
    if (!hre.network.config.polkavm)
        return;
    hre.network.polkavm = hre.network.config.polkavm;
    let artifactsPath = hre.config.paths.artifacts;
    if (!artifactsPath.endsWith("-pvm")) {
        artifactsPath = `${artifactsPath}-pvm`;
    }
    let cachePath = hre.config.paths.cache;
    if (!cachePath.endsWith("-pvm")) {
        cachePath = `${cachePath}-pvm`;
    }
    hre.config.paths.artifacts = artifactsPath;
    hre.config.paths.cache = cachePath;
    hre.artifacts = new artifacts_1.Artifacts(artifactsPath);
});
(0, config_env_1.task)(task_names_1.TASK_COMPILE).setAction(async (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
compilationArgs, _hre, runSuper) => {
    await runSuper(compilationArgs);
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, async (args, hre, runSuper) => {
    if (!hre.network.polkavm) {
        return await runSuper(args);
    }
    const contractsToCompile = hre.config.resolc.settings?.contractsToCompile;
    if (!contractsToCompile || contractsToCompile.length === 0) {
        return await runSuper(args);
    }
    const sourceNames = await runSuper(args);
    return sourceNames.filter((sourceName) => contractsToCompile.some((contractToCompile) => sourceName.includes(contractToCompile)));
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS, async (args, hre, runSuper) => {
    const { jobs, errors } = await runSuper(args);
    if (!hre.network.polkavm || hre.config.resolc.compilerSource !== "binary") {
        return { jobs, errors };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    jobs.forEach((job) => {
        job.solidityConfig.resolc = hre.config.resolc;
        job.solidityConfig.resolc.settings.compilerPath = hre.config.resolc.settings?.compilerPath;
    });
    return { jobs, errors };
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT, async ({ sourceName, contractName, contractOutput, }, hre) => {
    if (!hre.network.polkavm) {
        return (0, utils_1.getArtifactFromContractOutput)(sourceName, contractName, contractOutput);
    }
    const bytecode = contractOutput.evm?.bytecode?.object ||
        contractOutput.evm?.deployedBytecode?.object ||
        "";
    return {
        _format: constants_1.RESOLC_ARTIFACT_FORMAT_VERSION,
        contractName,
        sourceName,
        abi: contractOutput.abi,
        bytecode: `0x${bytecode}`,
        deployedBytecode: `0x${bytecode}`,
        linkReferences: {},
        deployedLinkReferences: {},
    };
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC, async (args, hre, runSuper) => {
    if (!hre.network.polkavm) {
        return await runSuper(args);
    }
    const solidityConfig = hre.config.solidity;
    const versions = new Set();
    for (const compiler of hre.config.solidity.compilers) {
        versions.add(compiler.version);
    }
    for (const override of Object.values(hre.config.solidity.overrides)) {
        versions.add(override.version);
    }
    if (versions.size > 1)
        throw new errors_1.ResolcPluginError("Multiple Solidity versions are not supported yet.");
    solidityConfig.compilers.forEach(async (compiler) => (0, utils_1.updateDefaultCompilerConfig)({ compiler }, hre.config.resolc));
    for (const [file, compiler] of Object.entries(solidityConfig.overrides)) {
        (0, utils_1.updateDefaultCompilerConfig)({ compiler, file }, hre.config.resolc);
    }
    return await (0, compile_1.compile)(hre.config.resolc, args.input);
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC, async (args, hre, runSuper) => {
    if (!hre.network.polkavm) {
        return await runSuper(args);
    }
    const solcBuild = await hre.run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD, {
        quiet: args.quiet,
        solcVersion: args.solcVersion,
        compilationJob: args.compilationJob,
    });
    await hre.run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START, {
        compilationJob: args.compilationJob,
        compilationJobs: args.compilationJobs,
        compilationJobIndex: args.compilationJobIndex,
        quiet: args.quiet,
    });
    let output;
    if (solcBuild.isSolcJs) {
        output = await hre.run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS, {
            input: args.input,
            solcJsPath: solcBuild.compilerPath,
        });
    }
    else {
        output = await hre.run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC, {
            input: args.input,
            solcPath: solcBuild.compilerPath,
        });
    }
    await hre.run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END, {
        compilationJob: args.compilationJob,
        compilationJobs: args.compilationJobs,
        compilationJobIndex: args.compilationJobIndex,
        output,
        quiet: args.quiet,
    });
    return { output, solcBuild };
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT, async ({ compilationJobs }, _hre, _runSuper) => {
    let count = 0;
    for (const job of compilationJobs) {
        count += job.getResolvedFiles().filter((file) => job.emitsArtifacts(file)).length;
    }
    if (count > 0) {
        console.info(chalk_1.default.green(`Successfully compiled ${count} Solidity ${(0, utils_1.pluralize)(count, "file")}`));
    }
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START).setAction(async ({ compilationJob, }) => {
    const count = compilationJob.getResolvedFiles().length;
    if (count > 0) {
        console.info(chalk_1.default.yellow(`Compiling ${count} Solidity ${(0, utils_1.pluralize)(count, "file")}`));
    }
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS).setAction(async ({ compilationJob, input, output, solcBuild, }, { artifacts, run, network }, runSuper) => {
    if (network.config.polkavm !== true) {
        return await runSuper({
            compilationJob,
            input,
            output,
            solcBuild,
        });
    }
    const version = compilationJob.getSolcConfig().version;
    const pathToBuildInfo = await artifacts.saveBuildInfo(version, solcBuild.longVersion, input, output);
    const artifactsEmittedPerFile = await Promise.all(compilationJob
        .getResolvedFiles()
        .filter((f) => compilationJob.emitsArtifacts(f))
        .map(async (file) => {
        const artifactsEmitted = await Promise.all(Object.entries(output.contracts?.[file.sourceName] ?? {}).map(async ([contractName, contractOutput]) => {
            logDebug(`Emitting artifact for contract '${contractName}'`);
            const artifact = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT, {
                sourceName: file.sourceName,
                contractName,
                contractOutput,
            });
            await artifacts.saveArtifactAndDebugFile(artifact, pathToBuildInfo);
            return artifact.contractName;
        }));
        return {
            file,
            artifactsEmitted,
        };
    }));
    return { artifactsEmittedPerFile };
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT, async (taskArgs, hre, runSuper) => {
    const compilerInput = await runSuper(taskArgs);
    if (!hre.network.polkavm) {
        return compilerInput;
    }
    if (hre.config.resolc.settings?.suppressWarnings &&
        hre.config.resolc.settings.suppressWarnings.length > 0) {
        compilerInput.suppressedWarnings = hre.config.resolc.settings.suppressWarnings;
    }
    return compilerInput;
});
(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS, async (taskArgs, hre, runSuper) => {
    if (!hre.network.polkavm) {
        return await runSuper(taskArgs);
    }
    const artifactsDir = hre.config.paths.artifacts;
    if (artifactsDir.slice(-4) !== "-pvm")
        fs_1.default.rmSync(artifactsDir, { recursive: true });
    const cacheDir = hre.config.paths.cache;
    if (cacheDir.slice(-4) !== "-pvm")
        fs_1.default.rmSync(cacheDir, { recursive: true });
});
//# sourceMappingURL=index.js.map