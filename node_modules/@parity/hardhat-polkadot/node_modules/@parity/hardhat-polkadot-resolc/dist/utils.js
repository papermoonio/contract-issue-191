"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getArtifactFromContractOutput = getArtifactFromContractOutput;
exports.getVersionComponents = getVersionComponents;
exports.updateDefaultCompilerConfig = updateDefaultCompilerConfig;
exports.pluralize = pluralize;
exports.extractCommands = extractCommands;
exports.extractImports = extractImports;
exports.mapImports = mapImports;
exports.orderSources = orderSources;
exports.deepUpdate = deepUpdate;
const constants_1 = require("hardhat/internal/constants");
const chalk_1 = __importDefault(require("chalk"));
const npm_1 = require("./compile/npm");
const constants_2 = require("./constants");
const errors_1 = require("./errors");
function getArtifactFromContractOutput(sourceName, contractName, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
contractOutput) {
    const evmBytecode = contractOutput.evm?.bytecode;
    const bytecode = evmBytecode?.object ?? "";
    const evmDeployedBytecode = contractOutput.evm?.deployedBytecode;
    const deployedBytecode = evmDeployedBytecode?.object ?? "";
    const linkReferences = evmBytecode?.linkReferences ?? {};
    const deployedLinkReferences = evmDeployedBytecode?.linkReferences ?? {};
    return {
        _format: constants_1.ARTIFACT_FORMAT_VERSION,
        contractName,
        sourceName,
        abi: contractOutput.abi,
        bytecode,
        deployedBytecode,
        linkReferences,
        deployedLinkReferences,
    };
}
function getVersionComponents(version) {
    const versionComponents = version.split(".");
    return [
        parseInt(versionComponents[0], 10),
        parseInt(versionComponents[1], 10),
        parseInt(versionComponents[2], 10),
    ];
}
function updateDefaultCompilerConfig(solcConfigData, resolc) {
    const compiler = solcConfigData.compiler;
    const settings = compiler.settings || {};
    let optimizer = {};
    if (resolc.settings?.optimizer && resolc.settings?.optimizer?.enabled) {
        optimizer = Object.assign({}, resolc.settings?.optimizer);
    }
    else if (resolc.settings?.optimizer?.enabled === false) {
        optimizer = Object.assign({}, { enabled: false });
    }
    else {
        optimizer = Object.assign({}, { enabled: false, runs: 200 });
    }
    compiler.settings = {
        ...settings,
        optimizer: { ...optimizer },
        evmVersion: resolc.settings?.evmVersion || compiler.settings.evmVersion,
    };
    const forceEVMLA = resolc.settings?.forceEVMLA && resolc.compilerSource === "binary";
    resolc.settings.forceEVMLA = forceEVMLA;
    const [major, minor] = getVersionComponents(compiler.version);
    if (major === 0 && minor < 7 && resolc.compilerSource === "binary") {
        console.warn(chalk_1.default.blue(constants_2.COMPILER_RESOLC_NEED_EVM_CODEGEN));
        compiler.settings.forceEVMLA = true;
    }
    if (resolc.compilerSource === "npm") {
        (0, npm_1.updateSolc)(compiler.version);
    }
    delete compiler.settings.metadata;
}
function pluralize(n, singular, plural) {
    if (n === 1) {
        return singular;
    }
    if (plural !== undefined) {
        return plural;
    }
    return `${singular}s`;
}
function extractStandardJSONCommands(config, commandArgs) {
    const settings = config.settings;
    commandArgs.push(`--standard-json`);
    if (settings.solcPath) {
        commandArgs.push(`--solc=${settings.solcPath}`);
    }
    if (settings.forceEVMLA) {
        commandArgs.push(`--force-evmla`);
    }
    if (settings.basePath) {
        commandArgs.push(`--base-path=${settings.basePath}`);
    }
    if (settings.includePaths) {
        commandArgs.push(`--include-paths=${settings.includePaths}`);
    }
    if (settings.allowPaths) {
        if (!settings.basePath) {
            throw new errors_1.ResolcPluginError(`--allow-paths option is only available when --base-path has a non-empty value.`);
        }
        commandArgs.push(`--allow-paths=${settings.allowPaths}`);
    }
    if (settings.debugOutputDir) {
        commandArgs.push(`--debug-output-dir=${settings.debugOutputDir}`);
    }
    if (settings.emitDourceDebugInfo) {
        commandArgs.push(`-g`);
    }
    if (settings.outputDir) {
        commandArgs.push(`--output-dir=${settings.outputDir}`);
    }
    if (settings.disableSolcOptimizer) {
        commandArgs.push(`--disable-solc-optimizer`);
    }
    return commandArgs;
}
function extractCommands(config) {
    const commandArgs = [];
    return extractStandardJSONCommands(config, commandArgs);
}
function extractImports(fileContent) {
    const importRegex = /import\s+(?:"([^"]+)"|'([^']+)'|(?:[^'"]+)\s+from\s+(?:"([^"]+)"|'([^']+)'))\s*;/g;
    const imports = [];
    let match;
    while ((match = importRegex.exec(fileContent)) !== null) {
        const importedPath = match[1] || match[2] || match[3] || match[4];
        if (importedPath) {
            imports.push(importedPath);
        }
    }
    return imports;
}
function mapImports(input) {
    const keys = Object.keys(input.sources);
    const map = new Map();
    for (const key of keys) {
        const importArray = extractImports(input.sources[key].content);
        map.set(key, importArray);
    }
    return map;
}
function orderSources(mapped) {
    const ordered = [];
    mapped.forEach((values, key) => {
        for (const value of values) {
            if (ordered.includes(value))
                continue;
            ordered.push(value);
        }
        if (ordered.includes(key))
            return;
        ordered.push(key);
    });
    return ordered;
}
function deepUpdate(a, b) {
    const keys = Object.keys(b.sources);
    const lastId = Object.keys(a.sources).length - 1;
    let nextIds = lastId + Object.keys(b.sources).length;
    if (Object.keys(a.sources).length === 0) {
        return b;
    }
    else {
        keys.forEach((key) => {
            a.contracts = Object.assign({}, a.contracts, { [key]: b.contracts[key] });
            a.sources = Object.assign({}, a.sources, {
                [key]: { id: nextIds, ast: b.sources[key].ast },
            });
            nextIds++;
        });
    }
    return a;
}
//# sourceMappingURL=utils.js.map