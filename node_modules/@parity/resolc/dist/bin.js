#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const commander = __importStar(require("commander"));
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const resolc = __importStar(require("."));
async function main() {
    // hold on to any exception handlers that existed prior to this script running, we'll be adding them back at the end
    const originalUncaughtExceptionListeners = process.listeners('uncaughtException');
    // FIXME: remove annoying exception catcher of Emscripten
    //        see https://github.com/chriseth/browser-solidity/issues/167
    process.removeAllListeners('uncaughtException');
    const program = new commander.Command();
    program.name('solcjs');
    program.version(resolc.version());
    program
        .option('--bin', 'Binary of the contracts in hex.')
        .option('--abi', 'ABI of the contracts.')
        .option('--base-path <path>', 'Root of the project source tree. ' +
        'The import callback will attempt to interpret all import paths as relative to this directory.')
        .option('--include-path <path...>', 'Extra source directories available to the import callback. ' +
        'When using a package manager to install libraries, use this option to specify directories where packages are installed. ' +
        'Can be used multiple times to provide multiple locations.')
        .option('-o, --output-dir <output-directory>', 'Output directory for the contracts.')
        .option('-p, --pretty-json', 'Pretty-print all JSON output.', false)
        .option('-v, --verbose', 'More detailed console output.', false)
        .argument('<files...>');
    program.parse(process.argv);
    const options = program.opts();
    const files = program.args;
    const destination = options.outputDir ?? '.';
    function abort(msg) {
        console.error(msg || 'Error occurred');
        process.exit(1);
    }
    function withUnixPathSeparators(filePath) {
        // On UNIX-like systems forward slashes in paths are just a part of the file name.
        if (os.platform() !== 'win32') {
            return filePath;
        }
        return filePath.replace(/\\/g, '/');
    }
    function makeSourcePathRelativeIfPossible(sourcePath) {
        const absoluteBasePath = options.basePath
            ? path.resolve(options.basePath)
            : path.resolve('.');
        const absoluteIncludePaths = options.includePath
            ? options.includePath.map((prefix) => {
                return path.resolve(prefix);
            })
            : [];
        // Compared to base path stripping logic in solc this is much simpler because path.resolve()
        // handles symlinks correctly (does not resolve them except in work dir) and strips .. segments
        // from paths going beyond root (e.g. `/../../a/b/c` -> `/a/b/c/`). It's simpler also because it
        // ignores less important corner cases: drive letters are not stripped from absolute paths on
        // Windows and UNC paths are not handled in a special way (at least on Linux). Finally, it has
        // very little test coverage so there might be more differences that we are just not aware of.
        const absoluteSourcePath = path.resolve(sourcePath);
        for (const absolutePrefix of [absoluteBasePath].concat(absoluteIncludePaths)) {
            const relativeSourcePath = path.relative(absolutePrefix, absoluteSourcePath);
            if (!relativeSourcePath.startsWith('../')) {
                return withUnixPathSeparators(relativeSourcePath);
            }
        }
        // File is not located inside base path or include paths so use its absolute path.
        return withUnixPathSeparators(absoluteSourcePath);
    }
    function toFormattedJson(input) {
        return JSON.stringify(input, null, options.prettyJson ? 4 : 0);
    }
    if (files.length === 0) {
        console.error('Must provide a file');
        process.exit(1);
    }
    if (!(options.bin || options.abi)) {
        abort('Invalid option selected, must specify either --bin or --abi');
    }
    const sources = {};
    for (let i = 0; i < files.length; i++) {
        try {
            sources[makeSourcePathRelativeIfPossible(files[i])] = {
                content: fs.readFileSync(files[i]).toString(),
            };
        }
        catch (e) {
            abort('Error reading ' + files[i] + ': ' + e);
        }
    }
    if (options.verbose) {
        console.log('>>> Compiling:\n' + toFormattedJson(sources) + '\n');
    }
    const output = await resolc.compile(sources);
    let hasError = false;
    if (!output) {
        abort('No output from compiler');
    }
    else if (output.errors) {
        for (const error in output.errors) {
            const message = output.errors[error];
            if (message.severity === 'warning') {
                console.log(message.formattedMessage);
            }
            else {
                console.error(message.formattedMessage);
                hasError = true;
            }
        }
    }
    fs.mkdirSync(destination, { recursive: true });
    function writeFile(file, content) {
        file = path.join(destination, file);
        fs.writeFile(file, content, function (err) {
            if (err) {
                console.error('Failed to write ' + file + ': ' + err);
            }
        });
    }
    for (const fileName in output.contracts) {
        for (const contractName in output.contracts[fileName]) {
            let contractFileName = fileName + ':' + contractName;
            contractFileName = contractFileName.replace(/[:./\\]/g, '_');
            if (options.bin) {
                writeFile(contractFileName + '.polkavm', Buffer.from(output.contracts[fileName][contractName].evm.bytecode.object, 'hex'));
            }
            if (options.abi) {
                writeFile(contractFileName + '.abi', toFormattedJson(output.contracts[fileName][contractName].abi));
            }
        }
    }
    // Put back original exception handlers.
    originalUncaughtExceptionListeners.forEach(function (listener) {
        process.addListener('uncaughtException', listener);
    });
    if (hasError) {
        process.exit(1);
    }
}
main().catch((err) => {
    console.error('Error:', err);
    process.exit(1);
});
//# sourceMappingURL=bin.js.map